<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image/PDF Converter Tool</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 13px;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 15px;
            min-height: 95vh;
        }

        /* Left Panel - File Management (Compact) */
        .file-panel {
            flex: 0 0 50px;
            background: white;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            height: calc(100vh - 20px);
        }

        .upload-btn {
            width: 40px;
            height: 40px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }

        .upload-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
        }

        .upload-btn.pdf {
            background: #9b59b6;
        }

        .upload-btn.pdf:hover {
            background: #8e44ad;
        }

        .file-list-container {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 5px;
            background: #f8f9fa;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 6px;
            border-bottom: 1px solid #eee;
            background: white;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .file-item:hover {
            background: #e8f4fc;
        }

        .file-item.active {
            background: #d6eaf8;
            border-left: 2px solid #3498db;
        }

        .file-item.dragging {
            opacity: 0.5;
            background: #d6eaf8;
        }

        .file-item.drag-over {
            border-top: 2px solid #3498db;
        }

        .file-icon {
            width: 20px;
            text-align: center;
            color: #7f8c8d;
            font-size: 12px;
            margin-right: 6px;
        }

        .drag-handle {
            cursor: move;
            color: #95a5a6;
            margin-right: 5px;
            padding: 2px;
        }

        .drag-handle:hover {
            color: #3498db;
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            color: #2c3e50;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 11px;
        }

        .file-size {
            color: #95a5a6;
            font-size: 10px;
        }

        .file-actions {
            display: none;
        }

        .file-item:hover .file-actions {
            display: block;
        }

        .file-action-btn {
            background: none;
            border: none;
            color: #7f8c8d;
            cursor: pointer;
            padding: 2px;
            border-radius: 3px;
            transition: all 0.2s;
            font-size: 11px;
        }

        .file-action-btn:hover {
            background: #eee;
            color: #e74c3c;
        }

        /* Main Panel - Preview & Editing */
        .main-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Top Row - Preview with tools */
        .preview-row {
            display: flex;
            gap: 15px;
            flex: 1;
        }

        .preview-section {
            flex: 1;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .preview-controls-top {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tool-btn {
            padding: 6px 10px;
            background: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #d5dbdb;
        }

        .tool-btn.active {
            background: #3498db;
            color: white;
        }

        .preview-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-btn {
            padding: 5px 8px;
            background: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .preview-container {
            flex: 1;
            text-align: center;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            background: #f8f9fa;
            border: 1px solid #eee;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #imagePreview {
            max-width: 100%;
            max-height: 100%;
            display: block;
            transition: all 0.3s;
        }

        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crop-selection {
            position: absolute;
            border: 2px solid #3498db;
            background-color: rgba(52, 152, 219, 0.1);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: 10;
        }

        .crop-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: white;
            border: 2px solid #3498db;
            border-radius: 50%;
            pointer-events: all;
            cursor: move;
        }

        .crop-handle.tl { top: -5px; left: -5px; cursor: nwse-resize; }
        .crop-handle.tr { top: -5px; right: -5px; cursor: nesw-resize; }
        .crop-handle.bl { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .crop-handle.br { bottom: -5px; right: -5px; cursor: nwse-resize; }

        /* Crop Controls */
        .crop-controls {
            display: none;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
        }

        .crop-controls.show {
            display: flex;
        }

        .crop-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .crop-apply {
            background: #2ecc71;
            color: white;
        }

        .crop-cancel {
            background: #e74c3c;
            color: white;
        }

        .crop-reset {
            background: #f39c12;
            color: white;
        }

        /* Right Panel - Editing Controls */
        .controls-section {
            flex: 0 0 250px;
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        .control-group {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #3498db;
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-options {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .option-btn {
            padding: 5px 8px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
            flex: 1;
            min-width: 40px;
            text-align: center;
        }

        .option-btn:hover {
            background: #f0f0f0;
        }

        .option-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        /* Global Options */
        .global-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 5px;
        }

        .global-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #eee;
        }

        .global-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .global-label {
            font-size: 12px;
            color: #2c3e50;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .action-btn {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .action-btn.primary {
            background: #3498db;
            color: white;
        }

        .action-btn.primary:hover {
            background: #2980b9;
        }

        .action-btn.secondary {
            background: #2ecc71;
            color: white;
        }

        .action-btn.secondary:hover {
            background: #27ae60;
        }

        .action-btn.tertiary {
            background: #9b59b6;
            color: white;
        }

        .action-btn.tertiary:hover {
            background: #8e44ad;
        }

        .action-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        /* Processing Overlay */
        .processing-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .processing-content {
            background: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
            max-width: 350px;
            width: 90%;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .preview-row {
                flex-direction: column;
            }
            
            .controls-section {
                flex: 0 0 auto;
            }
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .file-panel {
                flex-direction: row;
                height: auto;
                width: 100%;
                padding: 10px;
            }
            
            .file-list-container {
                display: none;
            }
            
            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel - Compact File Management -->
        <div class="file-panel">
            <button class="upload-btn" id="uploadImagesBtn" title="Add Images">
                <i class="fas fa-image"></i>
            </button>
            <button class="upload-btn pdf" id="uploadPdfBtn" title="Import PDF">
                <i class="fas fa-file-pdf"></i>
            </button>
            
            <div class="file-list-container" id="fileList">
                <!-- Files will appear here -->
            </div>
        </div>
        
        <!-- Main Panel -->
        <div class="main-panel">
            <!-- Preview Row -->
            <div class="preview-row">
                <!-- Image Preview Section -->
                <div class="preview-section">
                    <div class="preview-header">
                        <div class="preview-controls-top">
                            <button class="tool-btn" id="cropBtn" title="Crop Tool">
                                <i class="fas fa-crop-alt"></i> Crop
                            </button>
                            <button class="tool-btn" id="rotateLeftBtn" title="Rotate Left">
                                <i class="fas fa-undo"></i>
                            </button>
                            <button class="tool-btn" id="rotateRightBtn" title="Rotate Right">
                                <i class="fas fa-redo"></i>
                            </button>
                            <button class="tool-btn" id="resetBtn" title="Reset Filters">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                        </div>
                        
                        <div class="preview-nav">
                            <button class="nav-btn" id="prevBtn" disabled>
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <span id="imageCounter" style="font-size: 12px;">No images</span>
                            <button class="nav-btn" id="nextBtn" disabled>
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="preview-container" id="previewContainer">
                        <img id="imagePreview" src="https://via.placeholder.com/600x400?text=Select+or+Upload+Image" alt="Image Preview">
                        <div class="crop-overlay" id="cropOverlay"></div>
                    </div>
                    
                    <div class="crop-controls" id="cropControls">
                        <button class="crop-action-btn crop-apply" id="applyCropBtn">
                            <i class="fas fa-check"></i> Apply
                        </button>
                        <button class="crop-action-btn crop-cancel" id="cancelCropBtn">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                        <button class="crop-action-btn crop-reset" id="resetCropBtn">
                            <i class="fas fa-redo"></i> Reset
                        </button>
                    </div>
                </div>
                
                <!-- Right Controls Section -->
                <div class="controls-section">
                    <!-- Brightness -->
                    <div class="control-group">
                        <h3><i class="fas fa-sun"></i> Brightness</h3>
                        <div class="control-options">
                            <button class="option-btn active" data-brightness="0">0%</button>
                            <button class="option-btn" data-brightness="25">25%</button>
                            <button class="option-btn" data-brightness="50">50%</button>
                            <button class="option-btn" data-brightness="75">75%</button>
                            <button class="option-btn" data-brightness="100">100%</button>
                        </div>
                    </div>
                    
                    <!-- Sharpen -->
                    <div class="control-group">
                        <h3><i class="fas fa-magic"></i> Sharpen</h3>
                        <div class="control-options">
                            <button class="option-btn active" data-sharpen="0">0%</button>
                            <button class="option-btn" data-sharpen="25">25%</button>
                            <button class="option-btn" data-sharpen="50">50%</button>
                            <button class="option-btn" data-sharpen="75">75%</button>
                            <button class="option-btn" data-sharpen="100">100%</button>
                        </div>
                    </div>
                    
                    <!-- Saturation -->
                    <div class="control-group">
                        <h3><i class="fas fa-adjust"></i> Saturation</h3>
                        <div class="control-options">
                            <button class="option-btn" data-saturation="0">0%</button>
                            <button class="option-btn" data-saturation="50">50%</button>
                            <button class="option-btn active" data-saturation="100">100%</button>
                            <button class="option-btn" data-saturation="150">150%</button>
                            <button class="option-btn" data-saturation="200">200%</button>
                        </div>
                    </div>
                    
                    <!-- PDF Orientation -->
                    <div class="control-group">
                        <h3><i class="fas fa-compress"></i> PDF Orientation</h3>
                        <div class="control-options">
                            <button class="option-btn active" data-orientation="auto">Auto</button>
                            <button class="option-btn" data-orientation="portrait">Portrait</button>
                            <button class="option-btn" data-orientation="landscape">Landscape</button>
                        </div>
                    </div>
                    
                    <!-- Global Options -->
                    <div class="global-options">
                        <div class="global-option">
                            <input type="checkbox" id="invertColors" class="global-checkbox">
                            <label for="invertColors" class="global-label">
                                <i class="fas fa-inverse"></i> Invert Colors
                            </label>
                        </div>
                        
                        <div class="global-option">
                            <input type="checkbox" id="applyToAll" class="global-checkbox">
                            <label for="applyToAll" class="global-label">
                                <i class="fas fa-layer-group"></i> Apply to All
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Action Buttons Row -->
            <div class="action-buttons">
                <button id="processAllBtn" class="action-btn secondary" disabled>
                    <i class="fas fa-cogs"></i> Process All Images
                </button>
                <button id="printBtn" class="action-btn tertiary" disabled>
                    <i class="fas fa-print"></i> Print PDF
                </button>
                <button id="convertBtn" class="action-btn primary" disabled>
                    <i class="fas fa-file-pdf"></i> Download PDF
                </button>
            </div>
        </div>
    </div>
    
    <!-- Hidden File Inputs -->
    <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
    <input type="file" id="pdfInput" accept=".pdf" style="display: none;">
    
    <!-- Processing Overlay -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-content">
            <div class="spinner"></div>
            <h3 id="processingTitle" style="font-size: 14px; margin-bottom: 8px;">Processing Images...</h3>
            <p id="processingText" style="font-size: 12px; color: #7f8c8d;">Preparing your PDF document</p>
            <p id="progressText" style="font-size: 11px; color: #95a5a6; margin-top: 5px;">Please wait while we process your images</p>
        </div>
    </div>
    
    <!-- Include required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>
    
    <script>
        // Ensure jsPDF is properly loaded
        window.jsPDF = window.jspdf.jsPDF;
        
        // Global variables
        let images = [];
        let currentImageIndex = -1;
        let filters = {
            brightness: 0,
            sharpen: 0,
            saturation: 100,
            invertColors: false,
            pdfOrientation: 'auto'
        };
        
        // Crop variables
        let isCropping = false;
        let cropSelection = null;
        let cropStartX = 0;
        let cropStartY = 0;
        let cropCurrentX = 0;
        let cropCurrentY = 0;
        let cropMode = false;
        
        // Drag and drop variables
        let draggedItem = null;
        let dragOverItem = null;
        
        // DOM elements
        const imageInput = document.getElementById('imageInput');
        const pdfInput = document.getElementById('pdfInput');
        const uploadImagesBtn = document.getElementById('uploadImagesBtn');
        const uploadPdfBtn = document.getElementById('uploadPdfBtn');
        const fileList = document.getElementById('fileList');
        const imagePreview = document.getElementById('imagePreview');
        const cropOverlay = document.getElementById('cropOverlay');
        const cropBtn = document.getElementById('cropBtn');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const resetBtn = document.getElementById('resetBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const imageCounter = document.getElementById('imageCounter');
        const convertBtn = document.getElementById('convertBtn');
        const printBtn = document.getElementById('printBtn');
        const processAllBtn = document.getElementById('processAllBtn');
        const processingOverlay = document.getElementById('processingOverlay');
        const processingTitle = document.getElementById('processingTitle');
        const processingText = document.getElementById('processingText');
        const progressText = document.getElementById('progressText');
        const invertColorsCheckbox = document.getElementById('invertColors');
        const applyToAllCheckbox = document.getElementById('applyToAll');
        const previewContainer = document.getElementById('previewContainer');
        const cropControls = document.getElementById('cropControls');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');
        const resetCropBtn = document.getElementById('resetCropBtn');
        
        // Control elements
        const brightnessButtons = document.querySelectorAll('[data-brightness]');
        const sharpenButtons = document.querySelectorAll('[data-sharpen]');
        const saturationButtons = document.querySelectorAll('[data-saturation]');
        const orientationButtons = document.querySelectorAll('[data-orientation]');
        
        // Event Listeners
        uploadImagesBtn.addEventListener('click', () => imageInput.click());
        uploadPdfBtn.addEventListener('click', () => pdfInput.click());
        
        imageInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleImageFiles(e.target.files);
                imageInput.value = '';
            }
        });
        
        pdfInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handlePdfFile(e.target.files[0]);
                pdfInput.value = '';
            }
        });
        
        prevBtn.addEventListener('click', showPreviousImage);
        nextBtn.addEventListener('click', showNextImage);
        convertBtn.addEventListener('click', () => convertToPDF('download'));
        printBtn.addEventListener('click', () => convertToPDF('print'));
        processAllBtn.addEventListener('click', applyFiltersToAll);
        resetBtn.addEventListener('click', resetCurrentImage);
        
        cropBtn.addEventListener('click', toggleCropMode);
        rotateLeftBtn.addEventListener('click', () => rotateImage(-90));
        rotateRightBtn.addEventListener('click', () => rotateImage(90));
        applyCropBtn.addEventListener('click', applyCrop);
        cancelCropBtn.addEventListener('click', cancelCrop);
        resetCropBtn.addEventListener('click', resetCrop);
        
        invertColorsCheckbox.addEventListener('change', () => {
            filters.invertColors = invertColorsCheckbox.checked;
            if (applyToAllCheckbox.checked) {
                applyToAllImages();
            } else {
                applyFilters();
            }
        });
        
        // Control button event listeners
        brightnessButtons.forEach(button => {
            button.addEventListener('click', () => {
                brightnessButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                filters.brightness = parseInt(button.dataset.brightness);
                if (applyToAllCheckbox.checked) {
                    applyToAllImages();
                } else {
                    applyFilters();
                }
            });
        });
        
        sharpenButtons.forEach(button => {
            button.addEventListener('click', () => {
                sharpenButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                filters.sharpen = parseInt(button.dataset.sharpen);
                if (applyToAllCheckbox.checked) {
                    applyToAllImages();
                } else {
                    applyFilters();
                }
            });
        });
        
        saturationButtons.forEach(button => {
            button.addEventListener('click', () => {
                saturationButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                filters.saturation = parseInt(button.dataset.saturation);
                if (applyToAllCheckbox.checked) {
                    applyToAllImages();
                } else {
                    applyFilters();
                }
            });
        });
        
        orientationButtons.forEach(button => {
            button.addEventListener('click', () => {
                orientationButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                filters.pdfOrientation = button.dataset.orientation;
            });
        });
        
        // Mouse events for cropping
        previewContainer.addEventListener('mousedown', startCrop);
        previewContainer.addEventListener('touchstart', startCropTouch, { passive: false });
        
        // Functions
        async function handleImageFiles(files) {
            const validFiles = Array.from(files).filter(file => 
                file.type.startsWith('image/')
            );
            
            if (validFiles.length === 0) {
                alert('Please select valid image files (JPG, PNG, WebP, GIF)');
                return;
            }
            
            for (const file of validFiles) {
                await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            images.push({
                                file: file,
                                originalData: e.target.result,
                                filteredData: e.target.result,
                                originalWidth: img.width,
                                originalHeight: img.height,
                                filtersApplied: false,
                                cropArea: null,
                                rotation: 0,
                                type: 'image',
                                pageNumber: images.length + 1
                            });
                            resolve();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            }
            
            updateFileList();
            if (images.length > 0 && currentImageIndex === -1) {
                currentImageIndex = 0;
                updatePreview();
                enableActionButtons();
            }
        }
        
        async function handlePdfFile(file) {
            if (!file.type.includes('pdf')) {
                alert('Please select a PDF file');
                return;
            }
            
            processingTitle.textContent = 'Processing PDF';
            processingText.textContent = 'Extracting pages from PDF...';
            processingOverlay.style.display = 'flex';
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    progressText.textContent = `Processing page ${pageNum} of ${pdf.numPages}`;
                    
                    const page = await pdf.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1.5 });
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    images.push({
                        file: { name: `${file.name} - Page ${pageNum}` },
                        originalData: imageData,
                        filteredData: imageData,
                        originalWidth: canvas.width,
                        originalHeight: canvas.height,
                        filtersApplied: false,
                        cropArea: null,
                        rotation: 0,
                        type: 'pdf',
                        pageNumber: pageNum
                    });
                }
                
                updateFileList();
                if (images.length > 0) {
                    if (currentImageIndex === -1) {
                        currentImageIndex = images.length - pdf.numPages;
                    }
                    updatePreview();
                    enableActionButtons();
                }
                
                processingOverlay.style.display = 'none';
                alert(`PDF imported successfully! ${pdf.numPages} pages added.`);
                
            } catch (error) {
                console.error('Error processing PDF:', error);
                processingOverlay.style.display = 'none';
                alert('Error processing PDF file. Please try again.');
            }
        }
        
        function updateFileList() {
            fileList.innerHTML = '';
            images.forEach((image, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = `file-item ${index === currentImageIndex ? 'active' : ''}`;
                fileItem.dataset.index = index;
                fileItem.draggable = true;
                
                const fileIcon = image.type === 'pdf' ? 'fa-file-pdf' : 'fa-image';
                const cropIndicator = image.cropArea ? ' <span style="color:#e74c3c; font-size:9px;">[C]</span>' : '';
                const rotationIndicator = image.rotation !== 0 ? ` <span style="color:#f39c12; font-size:9px;">[${image.rotation}Â°]</span>` : '';
                
                fileItem.innerHTML = `
                    <div class="drag-handle" title="Drag to reorder">
                        <i class="fas fa-grip-vertical"></i>
                    </div>
                    <div class="file-icon">
                        <i class="fas ${fileIcon}"></i>
                    </div>
                    <div class="file-info">
                        <div class="file-name">${image.file.name}${cropIndicator}${rotationIndicator}</div>
                        <div class="file-size">${(image.originalData.length / 1024).toFixed(1)} KB</div>
                    </div>
                    <div class="file-actions">
                        <button class="file-action-btn remove-btn" title="Remove">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                `;
                
                // Click to select
                fileItem.addEventListener('click', (e) => {
                    if (!e.target.closest('.file-action-btn') && !e.target.closest('.drag-handle')) {
                        currentImageIndex = index;
                        updatePreview();
                        updateFileList();
                    }
                });
                
                // Drag and drop events
                fileItem.addEventListener('dragstart', handleDragStart);
                fileItem.addEventListener('dragover', handleDragOver);
                fileItem.addEventListener('dragleave', handleDragLeave);
                fileItem.addEventListener('drop', handleDrop);
                fileItem.addEventListener('dragend', handleDragEnd);
                
                // Remove button
                const removeBtn = fileItem.querySelector('.remove-btn');
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    images.splice(index, 1);
                    if (images.length === 0) {
                        currentImageIndex = -1;
                        disableActionButtons();
                        imagePreview.src = 'https://via.placeholder.com/600x400?text=Select+or+Upload+Image';
                        imageCounter.textContent = 'No images';
                        cropControls.classList.remove('show');
                        cropMode = false;
                        cropBtn.classList.remove('active');
                    } else {
                        if (currentImageIndex >= images.length) {
                            currentImageIndex = images.length - 1;
                        }
                        updatePreview();
                    }
                    updateFileList();
                });
                
                fileList.appendChild(fileItem);
            });
            
            // Scroll to current image
            const currentItem = fileList.querySelector('.file-item.active');
            if (currentItem) {
                currentItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }
        
        // Drag and Drop Functions
        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            if (this !== draggedItem) {
                this.classList.add('drag-over');
                dragOverItem = this;
            }
            return false;
        }
        
        function handleDragLeave() {
            this.classList.remove('drag-over');
        }
        
        function handleDrop(e) {
            e.stopPropagation();
            e.preventDefault();
            
            if (draggedItem !== this) {
                const draggedIndex = parseInt(draggedItem.dataset.index);
                const targetIndex = parseInt(this.dataset.index);
                
                // Reorder images array
                const [movedItem] = images.splice(draggedIndex, 1);
                images.splice(targetIndex, 0, movedItem);
                
                // Update currentImageIndex if needed
                if (currentImageIndex === draggedIndex) {
                    currentImageIndex = targetIndex;
                } else if (currentImageIndex > draggedIndex && currentImageIndex <= targetIndex) {
                    currentImageIndex--;
                } else if (currentImageIndex < draggedIndex && currentImageIndex >= targetIndex) {
                    currentImageIndex++;
                }
                
                // Update file list
                updateFileList();
            }
            
            return false;
        }
        
        function handleDragEnd() {
            const items = document.querySelectorAll('.file-item');
            items.forEach(item => {
                item.classList.remove('dragging');
                item.classList.remove('drag-over');
            });
            draggedItem = null;
            dragOverItem = null;
        }
        
        function updatePreview() {
            if (images.length > 0 && currentImageIndex >= 0) {
                const currentImage = images[currentImageIndex];
                imagePreview.src = currentImage.filteredData;
                imageCounter.textContent = `${currentImageIndex + 1} of ${images.length}`;
                prevBtn.disabled = currentImageIndex === 0;
                nextBtn.disabled = currentImageIndex === images.length - 1;
                
                // Update filter button states
                updateFilterButtons();
                
                // Update crop mode
                if (currentImage.cropArea) {
                    cropBtn.classList.add('active');
                }
            }
        }
        
        function updateFilterButtons() {
            if (currentImageIndex < 0) return;
            
            // Update brightness buttons
            brightnessButtons.forEach(btn => {
                if (parseInt(btn.dataset.brightness) === filters.brightness) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update sharpen buttons
            sharpenButtons.forEach(btn => {
                if (parseInt(btn.dataset.sharpen) === filters.sharpen) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update saturation buttons
            saturationButtons.forEach(btn => {
                if (parseInt(btn.dataset.saturation) === filters.saturation) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update invert colors checkbox
            invertColorsCheckbox.checked = filters.invertColors;
        }
        
        function showPreviousImage() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updatePreview();
                updateFileList();
            }
        }
        
        function showNextImage() {
            if (currentImageIndex < images.length - 1) {
                currentImageIndex++;
                updatePreview();
                updateFileList();
            }
        }
        
        function enableActionButtons() {
            convertBtn.disabled = false;
            printBtn.disabled = false;
            processAllBtn.disabled = false;
        }
        
        function disableActionButtons() {
            convertBtn.disabled = true;
            printBtn.disabled = true;
            processAllBtn.disabled = true;
        }
        
        // Crop Functions - FIXED
        function toggleCropMode() {
            if (images.length === 0) return;
            
            cropMode = !cropMode;
            cropBtn.classList.toggle('active', cropMode);
            cropControls.classList.toggle('show', cropMode);
            
            if (cropMode) {
                imagePreview.style.cursor = 'crosshair';
                alert('Click and drag to select crop area. Use Apply button to crop.');
            } else {
                imagePreview.style.cursor = 'default';
                removeCropSelection();
            }
        }
        
        function startCrop(e) {
            if (!cropMode) return;
            
            e.preventDefault();
            const rect = imagePreview.getBoundingClientRect();
            const containerRect = previewContainer.getBoundingClientRect();
            
            // Calculate relative position within the image
            const scaleX = imagePreview.naturalWidth / rect.width;
            const scaleY = imagePreview.naturalHeight / rect.height;
            
            // Get click position relative to image
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // Convert back to display coordinates
            cropStartX = (e.clientX - containerRect.left);
            cropStartY = (e.clientY - containerRect.top);
            cropCurrentX = cropStartX;
            cropCurrentY = cropStartY;
            
            isCropping = true;
            removeCropSelection();
            createCropSelection();
            updateCropSelection();
            
            document.addEventListener('mousemove', updateCropDrag);
            document.addEventListener('mouseup', endCropDrag);
        }
        
        function startCropTouch(e) {
            if (!cropMode) return;
            
            e.preventDefault();
            const rect = imagePreview.getBoundingClientRect();
            const containerRect = previewContainer.getBoundingClientRect();
            const touch = e.touches[0];
            
            const scaleX = imagePreview.naturalWidth / rect.width;
            const scaleY = imagePreview.naturalHeight / rect.height;
            
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;
            
            cropStartX = (touch.clientX - containerRect.left);
            cropStartY = (touch.clientY - containerRect.top);
            cropCurrentX = cropStartX;
            cropCurrentY = cropStartY;
            
            isCropping = true;
            removeCropSelection();
            createCropSelection();
            updateCropSelection();
            
            document.addEventListener('touchmove', updateCropDragTouch, { passive: false });
            document.addEventListener('touchend', endCropDrag);
        }
        
        function updateCropDrag(e) {
            if (!isCropping) return;
            
            const containerRect = previewContainer.getBoundingClientRect();
            cropCurrentX = e.clientX - containerRect.left;
            cropCurrentY = e.clientY - containerRect.top;
            updateCropSelection();
        }
        
        function updateCropDragTouch(e) {
            if (!isCropping) return;
            
            e.preventDefault();
            const containerRect = previewContainer.getBoundingClientRect();
            const touch = e.touches[0];
            cropCurrentX = touch.clientX - containerRect.left;
            cropCurrentY = touch.clientY - containerRect.top;
            updateCropSelection();
        }
        
        function endCropDrag() {
            isCropping = false;
            document.removeEventListener('mousemove', updateCropDrag);
            document.removeEventListener('mouseup', endCropDrag);
            document.removeEventListener('touchmove', updateCropDragTouch);
            document.removeEventListener('touchend', endCropDrag);
        }
        
        function createCropSelection() {
            cropSelection = document.createElement('div');
            cropSelection.className = 'crop-selection';
            cropOverlay.appendChild(cropSelection);
            
            // Add resize handles
            const handles = ['tl', 'tr', 'bl', 'br'];
            handles.forEach(handle => {
                const handleEl = document.createElement('div');
                handleEl.className = `crop-handle ${handle}`;
                handleEl.dataset.handle = handle;
                cropSelection.appendChild(handleEl);
            });
        }
        
        function updateCropSelection() {
            if (!cropSelection) return;
            
            const x = Math.min(cropStartX, cropCurrentX);
            const y = Math.min(cropStartY, cropCurrentY);
            const width = Math.abs(cropCurrentX - cropStartX);
            const height = Math.abs(cropCurrentY - cropStartY);
            
            const minSize = 20;
            const finalWidth = Math.max(width, minSize);
            const finalHeight = Math.max(height, minSize);
            
            // Constrain to container bounds
            const containerRect = previewContainer.getBoundingClientRect();
            const maxX = containerRect.width - finalWidth;
            const maxY = containerRect.height - finalHeight;
            
            const finalX = Math.max(0, Math.min(x, maxX));
            const finalY = Math.max(0, Math.min(y, maxY));
            
            cropSelection.style.left = `${finalX}px`;
            cropSelection.style.top = `${finalY}px`;
            cropSelection.style.width = `${finalWidth}px`;
            cropSelection.style.height = `${finalHeight}px`;
        }
        
        function removeCropSelection() {
            while (cropOverlay.firstChild) {
                cropOverlay.removeChild(cropOverlay.firstChild);
            }
            cropSelection = null;
        }
        
        function applyCrop() {
            if (!cropSelection) {
                alert('Please select a crop area first');
                return;
            }
            
            const currentImage = images[currentImageIndex];
            const rect = cropSelection.getBoundingClientRect();
            const imgRect = imagePreview.getBoundingClientRect();
            const containerRect = previewContainer.getBoundingClientRect();
            
            // Calculate the position of the image within the container
            const imgLeft = (containerRect.width - imgRect.width) / 2;
            const imgTop = (containerRect.height - imgRect.height) / 2;
            
            // Calculate crop area relative to the image
            const cropX = Math.max(0, rect.left - imgLeft);
            const cropY = Math.max(0, rect.top - imgTop);
            const cropWidth = Math.min(rect.width, imgRect.width - cropX);
            const cropHeight = Math.min(rect.height, imgRect.height - cropY);
            
            // Scale to original image dimensions
            const scaleX = currentImage.originalWidth / imgRect.width;
            const scaleY = currentImage.originalHeight / imgRect.height;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = cropWidth * scaleX;
            canvas.height = cropHeight * scaleY;
            
            const img = new Image();
            img.onload = function() {
                // Draw the cropped portion
                ctx.drawImage(
                    img,
                    cropX * scaleX, cropY * scaleY,
                    canvas.width, canvas.height,
                    0, 0,
                    canvas.width, canvas.height
                );
                
                currentImage.filteredData = canvas.toDataURL('image/jpeg', 0.9);
                currentImage.cropArea = {
                    x: cropX * scaleX,
                    y: cropY * scaleY,
                    width: canvas.width,
                    height: canvas.height
                };
                
                currentImage.filtersApplied = true;
                
                // Update preview
                imagePreview.src = currentImage.filteredData;
                removeCropSelection();
                cropControls.classList.remove('show');
                cropMode = false;
                cropBtn.classList.remove('active');
                updateFileList();
                
                alert('Crop applied successfully!');
            };
            img.src = currentImage.originalData;
        }
        
        function cancelCrop() {
            removeCropSelection();
            cropControls.classList.remove('show');
            cropMode = false;
            cropBtn.classList.remove('active');
            imagePreview.style.cursor = 'default';
        }
        
        function resetCrop() {
            const currentImage = images[currentImageIndex];
            currentImage.cropArea = null;
            currentImage.filteredData = currentImage.originalData;
            currentImage.filtersApplied = false;
            currentImage.rotation = 0;
            
            imagePreview.src = currentImage.filteredData;
            removeCropSelection();
            updateFilterButtons();
            updateFileList();
            
            alert('Image reset to original');
        }
        
        // Image Processing Functions - FIXED TO RESET TO ORIGINAL PROPERLY
        function rotateImage(degrees) {
            if (images.length === 0) return;
            
            const currentImage = images[currentImageIndex];
            currentImage.rotation = (currentImage.rotation + degrees) % 360;
            if (currentImage.rotation < 0) currentImage.rotation += 360;
            
            applyFilters();
        }
        
        function applyFilters() {
            if (images.length === 0) return;
            
            const currentImage = images[currentImageIndex];
            const img = new Image();
            
            img.onload = () => {
                let canvasWidth, canvasHeight;
                
                // Swap dimensions for 90/270 degree rotations
                if (currentImage.rotation === 90 || currentImage.rotation === 270) {
                    canvasWidth = img.height;
                    canvasHeight = img.width;
                } else {
                    canvasWidth = img.width;
                    canvasHeight = img.height;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                
                // Clear and rotate
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.rotate((currentImage.rotation * Math.PI) / 180);
                
                // Draw image - ALWAYS start from original data
                ctx.drawImage(img, -img.width / 2, -img.height / 2);
                ctx.restore();
                
                // Apply crop if exists
                let processedCanvas = canvas;
                if (currentImage.cropArea && currentImage.rotation === 0) {
                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = currentImage.cropArea.width;
                    cropCanvas.height = currentImage.cropArea.height;
                    const cropCtx = cropCanvas.getContext('2d');
                    
                    cropCtx.drawImage(
                        canvas,
                        currentImage.cropArea.x, currentImage.cropArea.y,
                        currentImage.cropArea.width, currentImage.cropArea.height,
                        0, 0, currentImage.cropArea.width, currentImage.cropArea.height
                    );
                    
                    processedCanvas = cropCanvas;
                }
                
                // Apply filters to the processed canvas
                applyImageFilters(processedCanvas.getContext('2d'), processedCanvas.width, processedCanvas.height);
                
                currentImage.filteredData = processedCanvas.toDataURL('image/jpeg', 0.9);
                currentImage.filtersApplied = true;
                
                imagePreview.src = currentImage.filteredData;
                updateFileList();
            };
            
            // Always start from original data to avoid cumulative effects
            img.src = currentImage.originalData;
        }
        
        function applyImageFilters(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Apply brightness - FIXED: 0% should be original
            if (filters.brightness !== 0) {
                const brightnessFactor = 1.0 + (filters.brightness / 100);
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = Math.min(255, data[i] * brightnessFactor);
                    data[i + 1] = Math.min(255, data[i + 1] * brightnessFactor);
                    data[i + 2] = Math.min(255, data[i + 2] * brightnessFactor);
                }
            }
            
            // Apply saturation - FIXED: 100% should be original
            if (filters.saturation !== 100) {
                const saturationFactor = filters.saturation / 100;
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                    
                    data[i] = Math.max(0, Math.min(255, gray + saturationFactor * (r - gray)));
                    data[i + 1] = Math.max(0, Math.min(255, gray + saturationFactor * (g - gray)));
                    data[i + 2] = Math.max(0, Math.min(255, gray + saturationFactor * (b - gray)));
                }
            }
            
            // Apply invert colors
            if (filters.invertColors) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Apply sharpen (separate pass) - FIXED: 0% should be original
            if (filters.sharpen > 0) {
                applySharpenFilter(ctx, width, height);
            }
        }
        
        function applySharpenFilter(ctx, width, height) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const tempData = new Uint8ClampedArray(data);
            
            const sharpenFactor = filters.sharpen / 200;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        const idx = (y * width + x) * 4 + c;
                        
                        const top = tempData[((y-1) * width + x) * 4 + c];
                        const bottom = tempData[((y+1) * width + x) * 4 + c];
                        const left = tempData[(y * width + (x-1)) * 4 + c];
                        const right = tempData[(y * width + (x+1)) * 4 + c];
                        const center = tempData[idx];
                        
                        const sharpened = center + sharpenFactor * (4 * center - top - bottom - left - right);
                        data[idx] = Math.max(0, Math.min(255, sharpened));
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function applyToAllImages() {
            images.forEach((image, index) => {
                if (index !== currentImageIndex) {
                    // Apply current filters to all images
                    const tempFilters = { ...filters };
                    // Keep individual rotations
                    tempFilters.rotation = image.rotation;
                    applyFiltersToImage(image, tempFilters);
                }
            });
            
            // Apply to current image
            applyFilters();
            updateFileList();
        }
        
        function applyFiltersToImage(image, filterSettings) {
            const img = new Image();
            img.onload = () => {
                let canvasWidth, canvasHeight;
                
                if (filterSettings.rotation === 90 || filterSettings.rotation === 270) {
                    canvasWidth = img.height;
                    canvasHeight = img.width;
                } else {
                    canvasWidth = img.width;
                    canvasHeight = img.height;
                }
                
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                
                ctx.save();
                ctx.translate(canvasWidth / 2, canvasHeight / 2);
                ctx.rotate((filterSettings.rotation * Math.PI) / 180);
                ctx.drawImage(img, -img.width / 2, -img.height / 2);
                ctx.restore();
                
                // Apply crop if exists
                let processedCanvas = canvas;
                if (image.cropArea && filterSettings.rotation === 0) {
                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = image.cropArea.width;
                    cropCanvas.height = image.cropArea.height;
                    const cropCtx = cropCanvas.getContext('2d');
                    
                    cropCtx.drawImage(
                        canvas,
                        image.cropArea.x, image.cropArea.y,
                        image.cropArea.width, image.cropArea.height,
                        0, 0, image.cropArea.width, image.cropArea.height
                    );
                    
                    processedCanvas = cropCanvas;
                }
                
                // Apply filters
                const finalCtx = processedCanvas.getContext('2d');
                const imageData = finalCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
                const data = imageData.data;
                
                // Brightness
                if (filterSettings.brightness !== 0) {
                    const brightnessFactor = 1.0 + (filterSettings.brightness / 100);
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.min(255, data[i] * brightnessFactor);
                        data[i + 1] = Math.min(255, data[i + 1] * brightnessFactor);
                        data[i + 2] = Math.min(255, data[i + 2] * brightnessFactor);
                    }
                }
                
                // Saturation
                if (filterSettings.saturation !== 100) {
                    const saturationFactor = filterSettings.saturation / 100;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                        data[i] = Math.max(0, Math.min(255, gray + saturationFactor * (r - gray)));
                        data[i + 1] = Math.max(0, Math.min(255, gray + saturationFactor * (g - gray)));
                        data[i + 2] = Math.max(0, Math.min(255, gray + saturationFactor * (b - gray)));
                    }
                }
                
                // Invert colors
                if (filterSettings.invertColors) {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];
                        data[i + 1] = 255 - data[i + 1];
                        data[i + 2] = 255 - data[i + 2];
                    }
                }
                
                finalCtx.putImageData(imageData, 0, 0);
                
                // Apply sharpen if needed
                if (filterSettings.sharpen > 0) {
                    applySharpenFilter(finalCtx, processedCanvas.width, processedCanvas.height);
                }
                
                image.filteredData = processedCanvas.toDataURL('image/jpeg', 0.9);
                image.filtersApplied = true;
            };
            img.src = image.originalData;
        }
        
        function applyFiltersToAll() {
            if (images.length === 0) return;
            
            processingTitle.textContent = 'Applying Filters to All Images';
            processingText.textContent = 'Processing all images...';
            processingOverlay.style.display = 'flex';
            
            let processed = 0;
            const total = images.length;
            
            images.forEach((image, index) => {
                setTimeout(() => {
                    applyFiltersToImage(image, filters);
                    processed++;
                    progressText.textContent = `Processed ${processed} of ${total} images`;
                    
                    if (processed === total) {
                        processingOverlay.style.display = 'none';
                        updatePreview();
                        updateFileList();
                        alert(`Filters applied to all ${total} images!`);
                    }
                }, index * 100);
            });
        }
        
        function resetCurrentImage() {
            if (images.length === 0) return;
            
            const currentImage = images[currentImageIndex];
            currentImage.filteredData = currentImage.originalData;
            currentImage.filtersApplied = false;
            currentImage.cropArea = null;
            currentImage.rotation = 0;
            
            // Reset filter settings
            filters.brightness = 0;
            filters.sharpen = 0;
            filters.saturation = 100;
            filters.invertColors = false;
            
            // Reset UI
            cropBtn.classList.remove('active');
            cropControls.classList.remove('show');
            cropMode = false;
            removeCropSelection();
            updateFilterButtons();
            
            imagePreview.src = currentImage.filteredData;
            updateFileList();
        }
        
        async function convertToPDF(action) {
            if (images.length === 0) return;
            
            processingTitle.textContent = 'Creating PDF Document';
            processingText.textContent = 'Please wait while we process your images';
            processingOverlay.style.display = 'flex';
            
            try {
                const { jsPDF } = window.jspdf;
                let pdf = null;
                
                for (let i = 0; i < images.length; i++) {
                    progressText.textContent = `Processing image ${i + 1} of ${images.length}`;
                    
                    await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            // Determine orientation
                            let orientation = 'portrait';
                            if (filters.pdfOrientation === 'landscape') {
                                orientation = 'landscape';
                            } else if (filters.pdfOrientation === 'auto') {
                                orientation = img.width > img.height ? 'landscape' : 'portrait';
                            }
                            
                            // Create PDF or add page
                            if (i === 0) {
                                pdf = new jsPDF({
                                    orientation: orientation,
                                    unit: 'mm',
                                    format: 'a4'
                                });
                            } else {
                                pdf.addPage(orientation === 'landscape' ? 'l' : 'p');
                            }
                            
                            const pageWidth = pdf.internal.pageSize.getWidth();
                            const pageHeight = pdf.internal.pageSize.getHeight();
                            const margin = 10;
                            const contentWidth = pageWidth - 2 * margin;
                            const contentHeight = pageHeight - 2 * margin;
                            
                            // Scale image to fit page
                            const scale = Math.min(
                                contentWidth / img.width,
                                contentHeight / img.height
                            );
                            
                            const scaledWidth = img.width * scale;
                            const scaledHeight = img.height * scale;
                            
                            const x = margin + (contentWidth - scaledWidth) / 2;
                            const y = margin + (contentHeight - scaledHeight) / 2;
                            
                            // Add image to PDF
                            pdf.addImage(
                                images[i].filteredData,
                                'JPEG',
                                x,
                                y,
                                scaledWidth,
                                scaledHeight
                            );
                            
                            resolve();
                        };
                        img.src = images[i].filteredData;
                    });
                }
                
                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:]/g, '-');
                const filename = `converted_${timestamp}.pdf`;
                
                if (action === 'download') {
                    pdf.save(filename);
                    processingOverlay.style.display = 'none';
                    alert(`PDF successfully created with ${images.length} pages!`);
                } else if (action === 'print') {
                    const pdfBlob = pdf.output('blob');
                    const pdfUrl = URL.createObjectURL(pdfBlob);
                    
                    const printWindow = window.open(pdfUrl, '_blank');
                    if (printWindow) {
                        printWindow.onload = function() {
                            printWindow.print();
                            setTimeout(() => {
                                URL.revokeObjectURL(pdfUrl);
                                processingOverlay.style.display = 'none';
                            }, 1000);
                        };
                    } else {
                        pdf.save(filename);
                        processingOverlay.style.display = 'none';
                    }
                }
                
            } catch (error) {
                console.error('Error creating PDF:', error);
                processingOverlay.style.display = 'none';
                alert(`Error creating PDF: ${error.message}`);
            }
        }
        
        // Initialize
        updateFilterButtons();
    </script>
</body>
</html>
